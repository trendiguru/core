__author__ = 'jeremy'

import numpy as np
import cv2
import os 
import json
import sys
import time
import subprocess
import socket
import copy
import logging
logging.basicConfig(level=logging.INFO)

from trendi.paperdoll import pd_falcon_client
from trendi.utils import imutils
from trendi import Utils,constants
from trendi.classifier_stuff.caffe_nns import conversion_utils
from trendi.constants import db
from trendi import pipeline
from trendi.classifier_stuff.caffe_nns import jrinfer

def get_pd_results_and_save(url=None,filename=None):
    if url is not None:
        print('getting pd results for '+url)
        image = Utils.get_cv2_img_array(url)
    elif filename is not None:
        print('getting pd results for '+filename)
        image = cv2.imread(filename)
    if image is None:
        print('image came back none')
        return None
    try:
        seg_res = pd_falcon_client.pd(image)
    except:
        print('exception in pd_falcon_client.pd '+str( sys.exc_info()[0]))
        return
#    print('segres:'+str(seg_res))
    if filename is not None:
        imgfilename = os.path.basename(filename) #use the actual on-disk filename if thats what we started with, otherwise use the name generated by pd
        #this will et saved to /home/jeremy/pd_output/filename
    else:
        try:
            imgfilename = seg_res['filename']+'.jpg'
        except:
            print('some error on imgfile name')
            imgfilename = str(int(time.time()))+'.jpg'
    print('filename '+imgfilename)
    if not 'mask' in seg_res:
        print('pd did not return mask')
        print seg_res
        return
    mask = seg_res['mask']
    label_dict = seg_res['label_dict']
    print('labels:'+str(label_dict))
    conversion_utils.count_values(mask)
    pose = seg_res['pose']
    mask_np = np.array(mask, dtype=np.uint8)
    print('masksize '+str(mask_np.shape))
    pose_np = np.array(pose, dtype=np.uint8)
    print('posesize '+str(pose_np.shape))
#    print('returned url '+seg_res['url'])
    converted_mask = convert_and_save_results(mask_np, label_dict, pose_np, imgfilename, image, url)
    dir = constants.pd_output_savedir
    Utils.ensure_dir(dir)
    full_name = os.path.join(dir,imgfilename)
#            full_name = filename
    bmp_name = full_name.strip('.jpg') + ('.bmp')  #this bmp should get generated by convert_and_save_results
#    imutils.show_mask_with_labels(bmp_name,constants.fashionista_categories_augmented_zero_based,original_image = full_name,save_images=False)
    return mask, label_dict,pose_np, converted_mask
#these are 1-based not 0-based

def get_pd_results(url=None,filename=None,img_arr=None):
    if url is not None:
        print('getting pd results for '+url)
        image = Utils.get_cv2_img_array(url)
    elif filename is not None:
        print('getting pd results for '+filename)
        image = cv2.imread(filename)
    elif img_arr is not None:
        print('getting pd results for img_arr ')
        image = img_arr
    if image is None:
        print('image came back none')
        return None
    try:
        seg_res = pd_falcon_client.pd(image)
    except:
        print('exception in pd_falcon_client.pd '+str( sys.exc_info()[0]))
        return
#    print('segres:'+str(seg_res))
    if not 'mask' in seg_res:
        print('pd did not return mask')
        print seg_res
        return
    mask = seg_res['mask']
    label_dict = seg_res['label_dict']
    print('labels:'+str(label_dict))
#    conversion_utils.count_values(mask)
    pose = seg_res['pose']
    mask_np = np.array(mask, dtype=np.uint8)
    print('masksize '+str(mask_np.shape))
    pose_np = np.array(pose, dtype=np.uint8)
    print('posesize '+str(pose_np.shape))
    return [mask, label_dict,pose_np]

def convert_and_save_results(mask, label_names, pose,filename,img,url,forwebtool=True):
    '''
    This saves the mask using the labelling fashionista_categories_augmented_zero_based
    :param mask:
    :param label_names:
    :param pose:
    :param filename:
    :param img:
    :param url:
    :return:
     '''
    fashionista_ordered_categories = constants.fashionista_categories_augmented_zero_based  #constants.fashionista_categories
    h,w = mask.shape[0:2]
    new_mask=np.ones((h,w,3),dtype=np.uint8)*255  # anything left with 255 wasn't dealt with in the following conversion code
    print('new mask size:'+str(new_mask.shape))
    success = True #assume innocence until proven guilty
    print('attempting convert and save, shapes:'+str(mask.shape)+' new:'+str(new_mask.shape))
    for label in label_names: # need these in order
        if label in fashionista_ordered_categories:
            fashionista_index = fashionista_ordered_categories.index(label) + 0  # number by  0=null, 55=skin  , not 1=null,56=skin
            pd_index = label_names[label]
            pixlevel_v2_index = constants.fashionista_aug_zerobased_to_pixlevel_categories_v2[fashionista_index]
            pixlevel_index = constants.fashionista_aug_zerobased_to_pixlevel_categories_v4_for_web[fashionista_index]
            if pixlevel_index is None:
                pixlevel_index = 0  #map unused categories (used in fashionista but not pixlevel v2)  to background
#            new_mask[mask==pd_index] = fashionista_index
     #       print('old index '+str(pd_index)+' for '+str(label)+': gets new index:'+str(fashionista_index)+':' + fashionista_ordered_categories[fashionista_index]+ ' and newer index '+str(pixlevel_v2_index)+':'+constants.pixlevel_categories_v2[pixlevel_v2_index])
            new_mask[mask==pd_index] = pixlevel_index
        else:
            print('label '+str(label)+' not found in regular cats')
            success=False
    if 255 in new_mask:
        print('didnt fully convert mask')
        success = False
    if success:
        try:   #write orig file
#            conversion_utils.count_values(new_mask,labels=constants.pixlevel_categories_v2)
            conversion_utils.count_values(new_mask,labels=constants.pixlevel_categories_v4_for_web)
            dir = constants.pd_output_savedir
            Utils.ensure_dir(dir)
            full_name = os.path.join(dir,filename)
#            full_name = filename
            print('writing output img to '+str(full_name))
            cv2.imwrite(full_name,img)
        except:
            print('fail in try 1, '+sys.exc_info()[0])
        try:   #write rgb mask
#            bmp_name = full_name.replace('.jpg','_pixv2.png')
            bmp_name = full_name.replace('.jpg','_pixv4.png')
            print('writing mask bmp to '+str(bmp_name))
            cv2.imwrite(bmp_name,new_mask)
            imutils.show_mask_with_labels(new_mask,labels=constants.pixlevel_categories_v4,original_image=full_name,save_images=True)
            if socket.gethostname() != 'extremeli-evolution-1':
                command_string = 'scp '+bmp_name+' root@104.155.22.95:/var/www/js-segment-annotator/data/pd_output/pd/'
                subprocess.call(command_string, shell=True)
                command_string = 'scp '+full_name+' root@104.155.22.95:/var/www/js-segment-annotator/data/pd_output/pd/'
                subprocess.call(command_string, shell=True)

        except:
            print('fail in try 2, '+str(sys.exc_info()[0]))
        try: #write webtool mask
            if forwebtool:
                webtool_mask = copy.copy(new_mask)
                webtool_mask[:,:,0]=0 #zero out the B,G for webtool - leave only R
                webtool_mask[:,:,1]=0 #zero out the B,G for webtool - leave only R
#                bmp_name=full_name.replace('.jpg','_pixv2_webtool.png')
                bmp_name=full_name.replace('.jpg','_pixv4_webtool.png')
                print('writing mask bmp to '+str(bmp_name))
                cv2.imwrite(bmp_name,webtool_mask)
                command_string = 'scp '+bmp_name+' root@104.155.22.95:/var/www/js-segment-annotator/data/pd_output/pd'
                subprocess.call(command_string, shell=True)
        except:
            print('fail in try 3, '+str(sys.exc_info()[0]))
        try:
            pose_name = full_name.strip('.jpg')+'.pose'
            with open(pose_name, "w+") as outfile:
                print('succesful open, attempting to write pose')
                poselist=pose[0].tolist()
#                json.dump([1,2,3], outfile, indent=4)
                json.dump(poselist,outfile, indent=4)
            if url is not None:
                url_name = full_name.strip('.jpg')+'.url'
                print('writing url to '+str(url_name))
                with open(url_name, "w+") as outfile2:
                    print('succesful open, attempting to write:'+str(url))
                    outfile2.write(url)
        except:
            print('fail in convert_and_save_results dude, bummer')
            print(str(sys.exc_info()[0]))
        return
    else:
        print('didnt fully convert mask, or unkown label in convert_and_save_results')
        success = False
        return

def convert_results(mask, pd_label_dict,pd_to_nd_label_converter,inlabels=constants.fashionista_categories_augmented_zero_based,outlabels=constants.pixlevel_categories_v3):
    '''
    This saves the mask using the labelling fashionista_categories_augmented_zero_based
    :param mask:
    :param label_names:
    :param pose:
    :param filename:
    :param img:
    :param url:
    :return:
     '''
    fashionista_ordered_categories = inlabels  #constants.fashionista_categories
    h,w = mask.shape[0:2]
    new_mask=np.ones((h,w,3),dtype=np.uint8)*255  # anything left with 255 wasn't dealt with in the following conversion code
    print('new mask size:'+str(new_mask.shape))
    success = True #assume innocence until proven guilty
    print('attempting convert, shapes:'+str(mask.shape)+' new:'+str(new_mask.shape))
    for mask_value in np.unique(mask):
        label=None
        for k,v in pd_label_dict.iteritems():
            if v==mask_value:
                label=k
                break
        if label in fashionista_ordered_categories:
            fashionista_index = fashionista_ordered_categories.index(label) + 0  # number by  0=null, 55=skin  , not 1=null,56=skin
            pd_index = pd_label_dict[label]
#            pixlevel_v2_index = constants.fashionista_aug_zerobased_to_pixlevel_categories_v2[fashionista_index]
#            pixlevel_index = constants.fashionista_aug_zerobased_to_pixlevel_categories_v4_for_web[fashionista_index]
            pixlevel_index = pd_to_nd_label_converter[fashionista_index]
            if pixlevel_index is None:
                pixlevel_index = 0  #map unused categories (used in fashionista but not pixlevel v2)  to background
#            new_mask[mask==pd_index] = fashionista_index
            print('v '+str(v)+' pd index '+str(pd_index)+' for '+str(label)+'  gets new index:'+str(pixlevel_index)+':' + outlabels[pixlevel_index]+' fashionista label :'+str(fashionista_ordered_categories[fashionista_index]+' fashindex '+str(fashionista_index)))
            new_mask[mask==pd_index] = pixlevel_index
        else:
            print('label '+str(label)+' not found in regular cats')
            success=False
    if 255 in new_mask:
        print('didnt fully convert mask')
        success = False
    if success:
        return new_mask
    else:
        print('didnt fully convert mask, or unkown label in convert_and_save_results')
        success = False
        return None


def get_pd_results_on_images_db(n_numerator,n_denominator):
    '''
    go thru images db and send images to pd
    :param n_numerator: start at image n_numerator*n_images/n_denominator
    :param n_denominator:
    :return:
    '''
    if db is None:
        print('couldnt open db')
        return {"success": 0, "error": "could not get db"}
    cursor = db.images.find()
    print('returned cursor')
    if cursor is None:  # make sure training collection exists
        print('couldnt get cursor ' )
        return {"success": 0, "error": "could not get collection"}
    doc = next(cursor, None)
    i = 0
    n = cursor.count()
    start = n*n_numerator/n_denominator
    print('found '+str(n)+' items in images db, starting at '+str(start))
    for i in range(start):
        doc = next(cursor, None)
    i=start
    while i < n:
        print('checking doc #' + str(i + 1)+' of '+str(n))
        if 'image_urls' in doc:
            for url in doc['image_urls']:
                get_pd_results(url)
        else:
            logging.warning('no url in doc ')
        i = i + 1
        doc = next(cursor, None)
    return {"success": 1}

def pd_test_iou_and_cats(images_file='/home/jeremy/image_dbs/pixlevel/pixlevel_fullsize_test_labels_v3.txt',
                         n_channels=len(constants.pixlevel_categories_v3),output_labels=constants.pixlevel_categories_v3,
                         pd_to_output_converter=constants.fashionista_augmented_zero_based_to_pixlevel_v3):
    '''
    :param images_file: file w lines of imgfile,labelfile. fash.augmented.zerobased list at 'pixlevel_fullsize_test_labels_faz.txt'
    :param n_channels: number of categories
    :param output_labels: what labels for output (used in legends)
    :param pd_to_output_converter: convert pd to outputlabels using this mapping
    :return: results from histogram - iou etc
    '''
    if not(os.path.exists(images_file)):
        logging.warning('file {} does not exist, exiting'.format(images_file))
        return
    with open(images_file,'r') as fp:
        lines = fp.readlines()
        if len(lines)==0:
            logging.warning('got no lines from {}, exiting'.format(images_file))
            return
        print('{} has lines like:\n{}'.format(images_file,lines[0]))
        imgfiles = [l.split()[0] for l in lines]
        labelfiles = [l.split()[1] for l in lines]
    hist = np.zeros((n_channels, n_channels))

    for image_file,labelfile in zip(imgfiles,labelfiles):
        image_arr = Utils.get_cv2_img_array(image_file)
        gt_arr = cv2.imread(labelfile)
        print('gt size {} img size {} for {} and {}'.format(gt_arr.shape,image_arr.shape,labelfile,image_file))
        result = get_pd_results(img_arr=image_arr)
        if result is not None:
            mask,labels,pose = result[:]
        else:
            logging.warning('got None result from get_pd_results in pd_test_iou_and_cats')
            continue
#        mask, labels, pose = paperdoll_parse_enqueue.paperdoll_enqueue(image_arr, async=False)
        conversion_utils.count_values(mask)
        converted_mask = convert_results(mask,labels,pd_to_nd_label_converter=pd_to_output_converter)
        conversion_utils.count_values(converted_mask)
        print('mask uniques {} converted uniques {} gt uniques {}'.format(np.unique(mask),np.unique(converted_mask),np.unique(gt_arr)))
        final_mask = pipeline.after_pd_conclusions(mask,labels)
        print('mask, after conclusions')
        conversion_utils.count_values(final_mask)
        converted_final_mask = convert_results(final_mask,labels,pd_to_nd_label_converter=pd_to_output_converter)
        conversion_utils.count_values(converted_final_mask)
        print('final mask uniques {} gt uniques {}'.format(np.unique(converted_final_mask),np.unique(gt_arr)))
    #before conclusions
        savename = os.path.basename(image_file).replace('.jpg','_legend.jpg')
        imutils.show_mask_with_labels(converted_mask,labels=output_labels,original_image=image_file,visual_output=True,savename=savename)
    #after conclusions
        savename_finalmask = os.path.basename(image_file).replace('.jpg','_afterpdconclusions_legend.jpg')
        imutils.show_mask_with_labels(converted_final_mask,labels=output_labels,original_image=image_file,visual_output=True,savename=savename_finalmask)
    #ground truth
        gtsavename = os.path.basename(image_file).replace('.jpg','_gt_legend.jpg')
        imutils.show_mask_with_labels(gt_arr,labels=output_labels,original_image=image_file,visual_output=True,savename=gtsavename)
    #mask (after conclusions)
        bmpname = os.path.basename(image_file).replace('.jpg','pd.bmp')
        cv2.imwrite(bmpname,converted_final_mask)
        print('saving naive legend to '+savename+' afterconclusions legend to '+savename_finalmask+' gt legend to '+gtsavename+', mask to '+bmpname)

        hist += jrinfer.fast_hist(gt_arr,converted_final_mask,n_channels)

    results = jrinfer.results_from_hist(hist,labels=labels)
    return results


if __name__ == "__main__":
 #   url = 'https://s-media-cache-ak0.pinimg.com/736x/3a/85/79/3a857905d8814faf49910f9c2b9806a8.jpg'
 #   get_pd_results(url=url)
    dir = '/home/jeremy/image_dbs/tamara_berg_street_to_shop/photos'
    tbphotos = [os.path.join(dir,im) for im in os.listdir(dir)]
    n = len(tbphotos)
    start = 0
    if len(sys.argv)>1:
        start = int(sys.argv[1])*n/3
    if len(sys.argv)>2:
        offset = int(sys.argv[2])

    print(str(len(tbphotos))+' images in '+dir+', starting at '+str(start))
    for f in tbphotos[start:]:
        i = tbphotos.index(f)
        print('working on image {} '.format(i))
        get_pd_results(filename=f)
        time.sleep(1)
